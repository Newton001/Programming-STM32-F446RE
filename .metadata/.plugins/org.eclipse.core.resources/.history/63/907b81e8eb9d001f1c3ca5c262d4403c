/*
 * rc522.c
 *
 *  Created on: Nov 3, 2024
 *      Author: newton
 */

#include "rc522.h"

uint8_t RC522_SPI_Transfer(uint8_t tx_data)
{
	uint8_t rx_data;
	HAL_SPI_TransmitReceive(&hspi1, &tx_data, &rx_data, 1, 100);
	return rx_data;
}

void write_RC522(uint8_t ADD, uint8_t val)
{
	//Pull the Chip Select Pin Down to activate the RFID
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
	RC522_SPI_Transfer((ADD<<1)&0x7E);
	RC522_SPI_Transfer(val);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);

}


uint8_t read_RC522(uint8_t addr)
{
	uint8_t val;
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
	RC522_SPI_Transfer(((addr<<1)&0x7E) | 0x80);
	val = RC522_SPI_Transfer(MI_OK);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);
	return val;
}

void SetBitMask(uint8_t reg, uint8_t mask)
{
	uint8_t temp = read_RC522(reg);
	write_RC522(reg, temp|mask);
}

void ClearBitMask(uint8_t reg,uint8_t mask)
{
	uint8_t temp = read_RC522(reg);
	write_RC522(reg, temp & (~mask));
}

void antenna_on(void)
{
	read_RC522(TxControlReg);
	SetBitMask(TxControlReg, DivlEnReg);
}

void antenna_off(void)
{
	ClearBitMask(TxControlReg, DivlEnReg);
}

void RC522_Reset(void)
{
	write_RC522(CommandReg, PCD_RESETPHASE);
}

void RC522_Init(void){
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);
	RC522_Reset();
	write_RC522(TModeReg, 0x8D);
	write_RC522(TPrescalerReg, 0x3E);
	write_RC522(TReloadRegL, 30);
	write_RC522(TReloadRegH, MI_OK);
	write_RC522(TxAutoReg, 0x40);
	write_RC522(ModeReg, 0x3D);
	antenna_on();
}

uint8_t RC522_ToCard(uint8_t command,uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint *backLen)
{
	uint8_t status = MI_ERR;
	uint8_t irqEn = 0x00;
	uint8_t waitIRq = 0x00;
	uint8_t lastBits;
	uint8_t n;
	uint i;

	switch(command)
	{
		case PCD_AUTHENT:
		{
			irqEn = 0x12;
			waitIRq = 0x10;
			break;
		}
		case PCD_TRANSCEIVE:
		{
			irqEn = 0x77;
			waitIRq = 0x30;
			break;
		}
		default:
			break;
	}
	 write_RC522(CommIEnReg, irqEn|0x80);
	 ClearBitMask(CommIrqReg, 0x80);
	 SetBitMask(FIFOLevelReg, 0x80);
	 write_RC522(CommandReg, PCD_IDLE);

	 for(i = 0; i<sendLen; ++i)
	 {
		 write_RC522(FIFODataReg, sendData[i]);
	 }

	 write_RC522(CommandReg, command);
	 if(command == PCD_TRANSCEIVE)
	 {
		 SetBitMask(BitFramingReg, 0x80);
	 }

	 i = 2000;

	 do
	 {
		 n = read_RC522(ComIrqReg);
		 i--;
	 }while ((i!=0) && (n&0x01) && !(n&waitIRq));

	 ClearBitMask(BitFramingReg, 0x80);

	 if(i!=0)
	 {
		 if(!(read_RC522(ErrorReg) & 0x1B))
		 {
			 status = MI_OK;
			 if(n & irqEn & 0x01)
			 {
				 status = MI_NOTAGERR;
			 }
			 if(command == PCD_TRANSCEIVE)
			 {
				 n = read_RC522(FIFOLevelReg);
				 lastBits = read_RC522(ControlReg) & 0x07;
				 if(lastBits)
				 {
					 *backLen = (n-1) * 8 + lastBits;
				 }
				 else
				 {
					 *backLen = n * 8;
				 }

				 if(n == 0)
				 {
					 n = 1;
				 }
				 if(n > MAX_LEN)
				 {
					 N = MAX_LEN;
				 }

				 for(i = 0; i<n; ++i)
				 {
					 backData[i] = read_RC522(FIFODataReg);
				 }
			 }
		 }
		 else
		 {
			 status = MI_ERR;
		 }
	 }
	 return status;
}

uint8_t RC522_Request(uint8_t reqMode, uint8_t *TagType)
{
	uint8_t status;
	uint8_t backBits;

	write_RC522(BitFramingReg, 0x07);
	TagType[0] = reqMode;
	status  = RC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backLen);

	if((status!=MI_OK)||(backBits !=0x10))
	{
		status = MI_ERR;
	}
}

uint8_t RC522_Anticoll(uint8_t *serNum)
{
	uint8_t status;
	uint8_t i;
	uint8_t serNumCheck = 0;
	uint unLen;

	write_RC522(BitFramingReg, 0x00);
	serNum[0] = PICC_ANTICOLL;
	serNum[1] = 0x20;
	status = RC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);

	if(status == MI_OK)
	{
		for(i = 0; i<4; ++i)
		{
			serNumCheck ^= serNum[i];
		}
		if(serNumCheck !=serNum[i])
		{
			status = MI_ERR;
		}
	}
	return status;
}

void CalculateCRC(uint8_t *pIndata, uint8_t len, uint8_t *pOutData)
{
	uint8_t i, n;
	ClearBitMask(DivIrqReg, 0x04);
	SetBitMask(FIFOLevelReg, 0x80);

	for(i = 0; i <len; ++i)
	{
		write_RC522(FIFODataReg, *(pIndata + i));
	}
	write_RC522(CommandReg, PCD_CALCCRC);

	i = 0xFF;
	do{
		n = read_RC522(DivIrqReg);
		i--;
	}
	while((i!=0) && (n&0x04));

	pOutData[0] = read_RC522(CRCResultRegL);
	pOutData[1] = read_RC522(CRCResultRegM);
}


uint8_t RC522_SelectTag(uint8_t *serNum)
{
	uint8_t i;
	uint8_t status;
	uint8_t size;
	uint recvBits;
	uint8_t buffer[9];

	buffer[0] = PICC_SElECTTAG;
	buffer[1] = 0x70;

	for( i =0; i<5; ++i)
	{
		buffer[i+2] = *(serNum + i);
	}

	CalculateCRC(buffer, 7, &buffer[7]);
	status = RC522_ToCard(PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits);

	if((status == MI_OK) && (recvBits == 0x18))
	{
		size = buffer[0];
	}
	else
	{
		size = 0;
	}
	return size;
}

uint8_t RC522_Auth(uint8_t authMode, uint8_t bloackAddr, uint8_t *sectorKey, uint8_t *serNum)
{
	uint8_t status;
	uint recvBits;
	uint8_t i;
	uint8__t buff[12];

	buff[0] = authMode;
	buff[1] = BlockAddr;

	for(i = 0; i <6; ++i)
	{
		buff[i+2] = *(sectorKey+i);
	}
	for(i = 0; i <4; ++i)
	{
		buff[i+8] = *(serNum+i);
	}
	status = RC522_ToCard(PCD_AUTHENT, buff, 12, buff, &recvBits);

	if((status !=MI_OK)||(!read_RC522(Status2Reg)&0x08))
	{
		status = MI_ERR;
	}
	return status;
}
